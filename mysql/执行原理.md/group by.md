## 执行过程

```text
select id%10 as m, count(*) as c from t1 group by m;
```

```text
group by m order by null 不使用排序
```

```text
创建内存临时表，表里有两个字段 m 和 c，主键是 m；

扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；

如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);
如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；

遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端
```

## 优化

### 索引

group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。

那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢

generated column 机制，用来实现列数据的关联更新。

你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，你也可以创建普通列和索引，来解决这个问题）。
```text
alter table t1 add column z int generated always as(id % 100), add index(z);
```

### 直接排序

一个 group by 语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，

插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就有点儿傻。

在 group by 语句中加入 SQL_BIG_RESULT 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。

MySQL 的优化器一看，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。

所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。

因此，下面这个语句

select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;
的执行流程就是这样的：

```text
初始化 sort_buffer，确定放入一个整型字段，记为 m；

扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；

扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；

排序完成后，就得到了一个有序数组。

据有序数组，得到数组里面的不同值，以及每个值的出现次数
```
