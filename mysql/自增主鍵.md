## 保存

MyISAM 引擎的自增值保存在数据文件中。
InnoDB 引擎的自增值，其实是保存在了内存里，并且到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为 MySQL 重启前的值”。

在 MySQL 5.7 及之前的版本，自增值保存在内存里。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。﻿

在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。

## 修改

### 步长

auto_increment_offset 和 auto_increment_increment

### 修改时机

执行器调用 InnoDB 引擎接口写入一行，传入的这一行的值是 (0,1,1);

InnoDB 发现用户没有指定自增 id 的值，获取表 t 当前的自增值 2；

将传入的行的值改成 (2,1,1);

将表的自增值改成 3

## 自增锁不连续

### 唯一键冲突

### 回滚

### 批量申请自增ID的优化

```text
语句执行过程中，第一次申请自增 id，会分配 1 个；

1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；

2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；

依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。
```


## 自增锁申请

innodb_autoinc_lock_mode，默认值是 1。

这个参数的值被设置为 0 时，语句执行结束后才释放锁；

这个参数的值被设置为 1 时：

普通 insert 语句，自增锁在申请之后就马上释放；
类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁


生产上，尤其是有 insert … select 这种批量插入数据的场景时，从并发插入数据性能的角度考虑，设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row
