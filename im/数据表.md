# 一、表结构

## （一）、用户表

- 用户ID
- 用户名

## （二）、关系链

### 1. 单聊

#### 好友关系表

- user
- another_user
- sequence（user级别）
- 是否删除
- 是否拉黑


#### 好友申请表

- user
- apply_user
- 申请语
- sequence（user级别）
- 添加来源
- 审批状态
- 阅读状态
- 删除状态

### 2. 群聊

#### 群组表

- 群组ID
- 群组名
- 群组类型
- 群主
- 加入方式
- 群成员上限
- sequence（群组级别）

#### 群成员表

- 群组ID
- 成员
- sequence（群组级别）
- 加入时间
- role（状态等、可用bit位存储）

### 分组

#### 分组表

- 分组ID
- 分组名
- 创建人
- 分组序列号

#### 分组成员表

- 分组ID
- 成员

## （三）、消息

### 1. 单聊

#### 单聊消息表

- 消息ID
- 消息序列号（会话级别）
- 消息类型（文本、图片等）
- 消息发送方
- 消息接收方
- 消息详情
- 消息时间戳

分区键 -> 消息ID

#### 单聊消息索引表

- user
- another_user
- 是否是收件箱
- 消息ID
- 消息序列号（可以冗余，减少查询复杂度）
- 消息序列号（user级别）

> 消息序列号是否要有一个用户级别的，如果用户要获取消息，难道要一个会话一个会话的拉取？

为每个用户存储一份消息，即写扩散

如果没有索引表，则查询消息时，需要查询单聊消息表。而一旦单聊消息表数据变多，则会影响查询性能

且如果单聊消息表分库分表了，则分区键难以确定，查询将变得更难

有了消息索引表，即使数据量变大，则可以根据user分区

#### 单聊消息会话表

- user
- another_user
- 消息ID
- 未读数
- 是否禁止提醒
- 是否制置顶
- 消息序列号（会话级别最新序列号）
- 已读消息序列号（会话级别最新序列号）

数据量变大时，根据user分区

理论上，根据两个用户ID可确定一个会话ID，所以可以不存储会话ID

两个用户之间共同会话的会话ID应该是一样的吧，我觉得是

### 2. 群聊

#### 群聊消息表

- 消息ID
- 群组ID
- 消息序列号（群组会话级别）
- 消息类型（文本、图片等）
- 消息发送方
- 消息详情
- 消息时间戳

分区键 -> 消息ID

#### 消息索引表

- 群组ID
- user
- another_user
- 是否是收件箱
- 消息ID
- 消息序列号（可以冗余，减少查询复杂度）


群组写扩散，可用户对消息进行各种处理（比如删除、收藏、已读等），存储压力大，所以限制大群的人员上线，或者对于超大群，退化为读扩散

# 二、序列号生成器

序列号需要递增，但是要连续么

理论上，可以做到连续，但是，也可以不连续

比如一个群组的仅维护一个序列号，当群组变更，比如成员变更，消息发送等，都可以申请群组的序列号
。这样对于消息而言，序列号其实是不连续的。

也可以专门为消息维护序列号，可实现消息的序列号是连续的

