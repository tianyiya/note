# 方案

1. 规模小的，使用MGET即可

2. 规模大的，单独为群维护在线群成员列表，使用分布式缓存作为一级缓存，本地服务内存作为二级缓存

群组在线状态缓存，使用哈希

结构如下：

```dtd
版本号
数据项1 时间戳
数据项2 时间戳
...
```

如

```dtd
hset group_1_online_status
version 5
user1_1 时间戳
user2_0 时间戳
...
```

其中`user_1 时间戳` 标识 `user1` 在 `时间戳` 更新了状态 到 `1`


客户端获取状态时，可获取最新状态的版本号，若一致，则直接使用本地缓存

否则传递时间戳，获取增量数据。且为了避免时间戳带来的不精确，可传递时间戳时多向前传递一些。


为避免进程内多个并发请求同时，可使用singleflight机制，仅由一个线程发起增量更新请求，其它请求阻塞等待即可

也许，使用zset是个更好的选择，因为zset可以将时间戳设置为score，使用zrangebyscore可直接获取到变更数据

3. 路由信息也可以采用本地缓存+增量更新的方式

4. 其实，直接广播到所有接入层节点也可以吧，这样就不用查询在线状态了


# 避免本地内存撑爆

为了避免本地内存撑死了，可以使用LRU算法淘汰缓存

也可以使用路由策略，每个群组固定有一个或一组机器处理，即每台机器只处理有限个群组


# 在线状态的一致性问题

心跳保存到分布式缓存中，并通过心跳进行续期，若不能及时续期，则删除在线状态及路由状态

正常情况下，在线状态与路由状态可及时地进行设置

比如用户上下线时，接入层将上下线转发到logic层，logic将上下线包装为事件后投递到MQ

在线状态服务可以及时更新在线状态信息及路由信息

> 群内成员在线状态需要接受什么信息?

1. 群成员变更信息
2. 群内成员上下线信息

> 如何保持群成员在线状态与在线状态的一致

1. 事件驱动更新

用户上线，下线通知，可由接入层转发至logic层，由logic层放入MQ中

在线服务与群组在线服务消费更新状态

2. 定时同步更新

定时同步群成员在线状态，启动定时任务，更新，由在线服务定时更新，可使用进程内的定时任务

