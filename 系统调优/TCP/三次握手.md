## 流程

客户端发送SYN

服务端接收SYN，回复SYN+ACK，并将请求放入半连接队列

客户端收到SYC+ACK后，回复ACK

服务端收到ACK后，将请求方式accept队列，并等待进行accept调用，若超时未调用accept则从全连接队列移出

## 优化

### SYN重试次数

`tcp_syc_retries`

内网环境可适当降低重试次数，以尽快让程序感知到错误

### 半连接队列

`tcp_max_syn_backlog`

当半连接队列满时，如果未开启`syncookies`，则丢弃连接

`tcp_syncookies=1`

服务端根据当前状态计算一个值，随SYN+ACK报文返回，客户端回复ACK时，携带该cookie，若服务端校验一致，则连接建立成功

仅用于syn泛洪攻击

服务端的计算和编解码会消耗一定性能；TCP的某些特性，比如TCP选项和MSS大小会受限制

SYN cookie的设计原则是在服务器端不保存任何关于连接的信息。因此，服务器无法进行精确的超时重传，因为它缺乏关于客户端接收窗口大小的信息来进行准确的计算。

```text
支持大窗口和高带宽的连接：SYN cookie 机制需要服务器在没有建立完整TCP连接之前就发送数据，
以响应客户端的SYN请求。这种机制使得服务器不能在建立完整的TCP连接之前进行窗口缩放和其他流量控制，从而影响到对大窗口和高带宽的连接支持。

无法进行精确的超时重传：在正常的TCP连接建立过程中，当发送方发送数据段后，
会等待一段时间来接收对方的ACK响应。如果没有收到ACK响应，则认为数据段丢失，并会重新发送该数据段。但是，在使用SYN cookie 建立TCP连接时，
服务器无法得知客户端的接收窗口大小，因此无法进行精确的超时重传。
因此，当数据段丢失时，服务器只能通过发送更多的SYN cookie来尝试重传，这可能会导致网络拥塞和延迟增加。

可能会降低安全性：SYN cookie 机制可以有效地防止SYN洪泛攻击，但它也可能会降低安全性。
由于SYN cookie 机制需要将一些连接请求的信息编码到Cookie中，攻击者可能会尝试反向工程生成Cookie，
从而获得有关服务器的敏感信息。此外，由于SYN cookie 机制会短暂地限制MSS大小，因此可能会增加网络的延迟和带宽占用率，
从而为攻击者提供更多的攻击机会。


```
### 服务端SYN+ACK重传

`tcp_synack_retries`

如果服务端没有收到ACK，会一直重发

同样，内网可适当降低重发次数

### 全连接队列

服务端收到ACK后，将连接放入accept队列，等待进程调用accept函数时将连接取出来，如果accept不能及时调用，可能导致队列溢出，从而连接被丢弃

#### 队列大小设置

listen函数里的backlog参数

系统级队列长度上限``somaxconn`

### 查看队列溢出情况

`netstat | grep 'SYNS TO LISTEN'`

`netstat | grep 'listen queue'`

### TFO

`tcp_fastopen`

初次建立连接时，客户端在TCP选项中设置使用TFO，此时正常三次握手，但服务端回复SYN+ACK时，会携带cookie，客户端收收到后，保存到本地，然后客户端回复ACK时，可以顺带携带请求

之后的连接，客户端可以再SYN中携带cookie和请求，服务端收到后验证，通过则交由服务端处理，并返回请求结果，也就是不用等待客户端的ACK报文
