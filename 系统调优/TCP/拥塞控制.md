## 超时重传

超时重传时间为RTO，应略大于RTT，根据历史RTT动态调整，超时重发的数据，再次重发时，超时间隔加倍

## 快速重传

发送方收到3个重复ACK后，快速重传，使用SACK确定要重传的报文

## SACK

表示需要重传哪些报文

## 滑动窗口

已发送并且已收到ACK，可以推送窗口前进

已发送但为收到ACK

未发送但是在接收方处理范围内

未发送但是不在接收方处理范围内

## 流量控制

TCP不允许同时缩小缓冲区及接受窗口，而是要先缩小窗口再缩小缓冲区，避免丢包

通过`tcp_congestion_control`设置流量控制算法

## 糊涂窗口综合征

如果接收方太忙，导致发送方频繁发送少量的数据，造成不要的开销


当接收方窗口过小时，接受方可直接关闭窗口

发送方避免发送少量数据库

可以使用nagle算法，延迟处理，仅当窗口大小>=1MSS时或接收到ACK时才发送数据。但对于一些需要小数据包交互的场景，要关闭nagle算法，如telnet、ssh

## 拥塞窗口

发送窗口 = min（拥塞窗口，接收窗口）

## 流量控制

### 慢启动

假设初始cwnd=1MSS，发送方每收到一个ACK，则加1，直到到达慢启动门限

实际上，为了提高效率，初始的cwnd为10MSS

### 拥塞避免

当cwnd超过慢启动门限，开始拥塞避免，每当收到一个 ACK 时，cwnd 增加 1/cwnd

### 拥塞发生

当发生超时重传时，进入拥塞避免算法

此时慢启动门限 设为 cwnd/2， cwnd 重置为 1，重新进入慢启动

### 快速恢复

当发生快速重传时，慢启动门限 设为 cwnd/2， cwnd = cwnd/2 

进入快速恢复

设置拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了） 重传丢失的数据包；

如果再收到重复的 ACK，那么 cwnd 增加 1；

如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；






